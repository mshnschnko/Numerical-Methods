\documentclass[a4paper,14pt]{report}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{setspace}
\usepackage{geometry}
\geometry{top=2cm}
\geometry{bottom=2cm} % отступ снизу
\geometry{left=2cm} % отступ справа
\geometry{right=2cm} % отступ слева
\usepackage{graphicx}
\usepackage{amsmath}
\graphicspath{{./images/}}
\makeatletter %%%%% <---- Starting chapter without a pagebreak
\renewcommand\chapter{\par%
	\thispagestyle{plain}% \global\@topnum\z@
	\@afterindentfalse \secdef\@chapter\@schapter}
\makeatother

\begin{document}
	
	\begin{center}
		\hfill \break
		\begin{center}
			\huge{Санкт-Петербургский политехнический университет\\
				Высшая школа прикладной математики\\
				и вычислительной физики, ФизМех}
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		
		\huge{Направление подготовки\\
			<<Прикладная математика и информатика>>}\\
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\fontsize{14pt}{14pt}\selectfont
		Отчет по лабораторной работе №3\\
		<<Решение СЛАУ итерационными методами>>\\
		\begin{center}
			Дисциплина: <<Численные методы>>
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
	\end{center}
	\hfill \break
	\hfill \break
	\fontsize{12pt}{12pt}\selectfont 
	\begin{tabular}{cccc}
		\hspace{1cm}Выполнил студент гр. 5030102/00003 & {\hspace{3cm}} & & Анищенко М.Д. \\\\
		\hspace{-3cm}Преподаватель: &{\hspace{1cm}}& & {\hspace{1cm}} Курц В.В. \\\\
	\end{tabular}\\
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\begin{center} Санкт-Петербург 2021 \end{center}
	\thispagestyle{empty}
	
	\newpage
	\tableofcontents{}
	\clearpage
	\chapter{Формулировка задачи и её формализация}
	Большинство расчётных математических задач сводится к решению систем линейных алгебраических уравнений. Существует два типа методов решения таких задач: прямые и итерационные. В данной работе будет рассмотрен итерационный метод, т.е. метод, который приводит к приближенному ответу за некоторое количество итераций, которое зависит от заданной точности.
	\section{Формализация задачи}
	Пусть дана система из n линейных уравнений с n неизвестными. \(Ax=B\) -- её матричная форма записи. Требуется найти вектор X, удовлетворющий данному матричному уравнению и являющийся решением данной СЛАУ. В этой работе буде использован метод Якоби.
	\section{Постановка задачи}
	\begin{enumerate}
		\item Исследовать условия применимости метода и алгоритм его работы.
		\item Решить СЛАУ данным методом.
		\item Построить график для анализа выбранного метода, а именно: зависимость числа итераций от степени диагонального преобладания матрицы.
	\end{enumerate}
	\chapter{Алгоритм метода и условия его применимости}
	\section{Условия применимости метода}
	Достаточное условие сходимости: диагональное преобладание матрицы.
	\[\sum\limits_{j=1,j\neq i}^n |a_{ij}| < |a_{ii}|, i=1,\ldots,n\]
	\section{Алгоритм метода}
	Пусть имеется матрица \(Ax=b\). Для метода простых итераций имеем формулу
	\[x=(E-\alpha B^{-1}A)x+\alpha B^{-1}b\]
	Метод Якоби - можно рассматривать как частный случай метода простых итераций, когда \(\alpha=1, B=D=diag(A)\).\\
	Тогда получаем итерационную формулу
	\[x^{(k+1)}=(E-D^{-1}A)x^{(k)}+D^{-1}b\]
	Применяя здесь форму записи \(x=Cx+g\), принимаем \(C=(E-D^{-1}A), g = D^{-1}b\).
	Матрицу \(C\) можно посчитать следующим образом:
	$$C=
	\begin{bmatrix}
		0& -\frac{a_{12}}{a_{11}}& -\frac{a_{13}}{a_{11}}& \cdots& -\frac{a_{1n}}{a_{11}}\\
		-\frac{a_{21}}{a_{22}}& 0& -\frac{a_{23}}{a_{22}}& \cdots& -\frac{a_{2n}}{a_{22}}\\
		\cdots& \cdots& \cdots& \cdots& \cdots\\
		-\frac{a_{n1}}{a_{nn}}& -\frac{a_{n2}}{a_{nn}}& -\frac{a_{n3}}{a_{nn}}& \cdots& 0\\
	\end{bmatrix}
	$$
	Общее условие останоки:
	\[||x^{(k)}-x^{(k-1)}||<\frac{1-||C||}{||C||}\epsilon\]
	При хорошо обусловленой матрице (\(||C||\leq\frac{1}{2}\)):
	\[||x^{(k)}-x^{(k-1)}||<\epsilon\]
	\chapter{Анализ задачи}
	Существование СЛАУ зависит от введенной матрицы \(A\). Для построения матрицы зададим её как \(A=QDQ^T\), где \(Q\) -- ортогональная матрица, \(D\) -- диагональная. Затем разделим все элементы каждой строки (кроме диагонального) на сумму модулей элементов этой строки (опять же, в сумму не будет входить элемент главной диагонали). Таким образом мы гарантируем диагональное преобладание матрицы.
	\chapter{Тестовый пример}
	В качестве тестового примера возьмём следующую систему линейных алгебраических уравнений:
	$$
	\begin{cases}
		5x_1+x_2-2x_3=4\\
		x_1+4x_2-1x_3=4,\\
		-2x_1-1x_2-3x_3=0\\
	\end{cases}
	A =
	\begin{pmatrix}
		5& 1& -2\\
		1& 4& -1\\
		-2& -1& 3\\
	\end{pmatrix},
	B=
	\begin{pmatrix}
		4\\
		4\\
		0\\
	\end{pmatrix},
	C =
	\begin{pmatrix}
	0& -0.2& 0.4\\
	-0.25& 0& 0.25\\
	0.667& 0.333& 0\\
	\end{pmatrix}
	$$
	Нетрудно сосчитать, что корни \(x=(1,1,1)\). Проведем несколько первых итераций согласно методу Якоби и принимая точность равную 0.1:
	\[x=(0.8, 1, 0)\]
	\[x=(0.6, 0.8, 0.8667)\]
	\[x=(0.9867, 1.0667, 0.6667)\]
	\[x=(0.8533, 0.92, 1.0133)\]
	\[x=(1.0213, 1.04, 0.8756)\]
	\[x=(0.9422, 0.9635, 1.0275)\]
	Как мы видим, корни сходятся к требуемым значениям. На данной итерации погрешность составляет 0.1, но тем не менее, видно, что корни будут найдены с необходимой точностью спустя еще несколько итераций.
	\newpage
	\chapter{Контрольные тесты}
	Создадим 100 матриц размером 10$\times$10 с числом обусловленноти 10 и будем менять степень диагонального преобладания с помощью деления элементов не просто на сумму их модулей, а на сумму модулей, умноженную на некоторый коэффициент. Этот коэффициент будет принимать 100 разных значений, равномерно распределенных на отрезке \([0.1;10]\)
	\chapter{Модульная структура программы}
	\begin{itemize}
		\item double** CreateMatrix(int n, int m) -- функция, выделяющая память для матрицы заданного размера.
		\item void DestroyMatrix(double** A, int n) - функция очистки памяти.
		\item double** ReadMatrix(FILE* matrixfile, FILE* freekoeffile, int n) -- функция для чтения матрицы из файла.
		\item void PrintVector(FILE* rootsfileforrec, double* arr, int n) -- функция для записи вектора корней в файл.
		\item double** GetInverseDiagMatrix(double** diagMatrix, int n) -- функция получения матрицы, обратной к диагональной.
		\item double* MxV(double** M, double* V, int n) -- функция умножения матрицы на вектор.
		\item double** MxM(double** A, double** B, int n) -- функция матричного умножения.
		\item double* VectorsSum(double* V1, double* V2, int n) -- функция для вычисления суммы векторов.
		\item double** DiagMatrix(double** A, int n) -- функция для составления диагональной матрицы.
		\item double NormVecDif(double* V1, double* V2, int n) -- функция для вычисления нормы вектора.
		\item double* Jacobi(double** matrix, int n, double* average, int* iters) -- функция, реализующая метод Якоби
		\item int main(void) -- основное тело программы.
	\end{itemize}
	\chapter{Численный анализ}
	\section{Зависимость числа итераций от степени диагонального преобладания}
	Воспользуемся пакетом MATLAB для построения данного графика.
	\begin{center}
		\includegraphics{degree}
	\end{center}
	По графику мы можем видеть, что количество итераций имеет обратную зависимость и приближается к кривой вида \(y=\frac{k}{x}\).
	\newpage
	\section{Сравнение времени работы итерационного и прямого метода}
	Сравним методы прогонки и Якоби для одинаковых СЛАУ. Для метода Якоби зададим точность \(10^{-15}\). Для этого используем СЛАУ размерности от 10$\times$10 до 500$\times$500 с шагом в 10, замерим время за 100 запусков и усредним его.\\
	\begin{center}
		\includegraphics[scale=0.55]{timeJ}
		\includegraphics[scale=0.55]{Time}
	\end{center}
	Слева мы наблюдаем график для метода Якоби, а справа для метода прогонки. Как ни странно, но метод прогонки сработал быстрее, хотя обычно итерационые методы работают быстрее прямых. Возможно это связано с тем, что метод прогонки применим для трехдиагональных СЛАУ, поэтому он не требует больших объемов вычислений. В то время как метод прогонки взаимодействует с каждым элементом матрицы.
	\chapter{Общие выводы}
	Метод Якоби достаточно быстро находит решение СЛАУ с заданной точностью.При этом для хорошо обусловленной матрицы возрастание степени диагонального преобладания хорошо сказывается на количестве итераций. Однако метод Якоби проигрывает методу прогонки, вероятно, из-за специфики второго.
\end{document}