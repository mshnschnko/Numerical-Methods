\documentclass[a4paper,14pt]{report}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{setspace}
\usepackage{geometry}
\geometry{top=2cm}
\geometry{bottom=2cm} % отступ снизу
\geometry{left=2cm} % отступ справа
\geometry{right=2cm} % отступ слева
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\graphicspath{{./images/}}
\makeatletter %%%%% <---- Starting chapter without a pagebreak
\renewcommand\chapter{\par%
	\thispagestyle{plain}% \global\@topnum\z@
	\@afterindentfalse \secdef\@chapter\@schapter}
\makeatother

\begin{document}
	
	\begin{center}
		\hfill \break
		\begin{center}
			\huge{Санкт-Петербургский политехнический университет\\
				Высшая школа прикладной математики\\
				и вычислительной физики, ФизМех}
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		
		\huge{Направление подготовки\\
			<<Прикладная математика и информатика>>}\\
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\fontsize{14pt}{14pt}\selectfont
		Отчет по лабораторной работе №3\\
		<<Численное интегрирование с помощью формул Ньютона-Котеса>>\\
		\begin{center}
			Дисциплина: <<Численные методы>>
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
	\end{center}
	\hfill \break
	\hfill \break
	\fontsize{12pt}{12pt}\selectfont 
	\begin{tabular}{cccc}
		\hspace{1cm}Выполнил студент гр. 5030102/00003 & {\hspace{3cm}} & & Анищенко М.Д. \\\\
		\hspace{-3cm}Преподаватель: &{\hspace{1cm}}& & {\hspace{1cm}} Курц В.В. \\\\
	\end{tabular}\\
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\begin{center} Санкт-Петербург 2022 \end{center}
	\fontsize{14pt}{14pt}\selectfont 
	\thispagestyle{empty}
	
	\newpage
	\tableofcontents{}
	\clearpage
	\chapter{Формулировка задачи и её формализация}
	\section{Формулировка задачи}
	Представим определённый интеграл на промежутке \([a,b]\) функции \(F(x)\) в виде
	\[\int\limits_a^b F(x)dx = \int\limits_a^b p(x)f(x)dx\]
	где \(p(x)\) --- весовая функция. Необходимо вычислить приближенное значение интеграла, 
	используя квадратурные формулы:
	\[\int\limits_a^b p(x)f(x)dx \approx \sum\limits_{k=1}^n A_k f(x_k)\]
	где \(A_k\) --- коэффициенты, а \(x_k\) --- узлы квадратурной функции.
	\section{Формализация}
	В данном варианте необходимо решить задачу, используя методы левых и правых прямоугольников, для следующей функции на отрезке \([0,3]\):
	\[F(x)=x^2\cos(2x)+1\]
	Формула прямоугольников --- это одна из формул Ньютона-Котеса, поэтому
	\[p(x)=1, h = \frac{b-a}{n}, x_i=a+ih\]
	\chapter{Алгоритм метода и условия его применимости}
	\section{Алгоритм метода}
	Приближенное значение интеграла функции по формуле прямоугольников находится, как сумма значений интегралов на каждом отрезке разбиения по формулам:\\
	Для левых прямоугольников:
	\[\int\limits_a^b F(x)dx = \int\limits_a^b f(x)dx \approx h \sum\limits_{i=0}^{n-1} f(x_i)\]
	Для правых прямоугольников:
	\[\int\limits_a^b F(x)dx = \int\limits_a^b f(x)dx \approx h \sum\limits_{i=1}^{n} f(x_i)\]
	Для достижения заданной точности будем использовать правило Рунге:
	\[\Delta_{2n} \approx 3|I_{2n} - I_n|\]
	\section{Условия применимости}
	Функция \(F(x)\) должна быть непрерывна на отрезке \([a,b]\).
	\newpage
	\chapter{Анализ задачи}
	Для корректной работы метода необходимо задать узлы, согласно формуле \(x_i=a+ih\). Также выбранная функция Должна удовлетворять условиям применимости. Произведение степенной и тригонометрической функций непрерывно на отрезке \([a,b]\).
	\chapter{Тестовый пример}
	Тестовый пример выполним для нашей функции \(F(x) = x^2\cos(2x)+1\) на отрезке \([0,3]\). Точное значение интеграла найдем классическим способом. Опуская подробные шаги, получаем
	\[\int\limits_0^3 x^2\cos(2x)+1 dx = \frac{17\sin(6)+6\cos(6)+12}{4} \approx 3.252739\]
	Теперь воспользуемся двумя вариациями метода
	\section{Левые прямоугольники}
	\begin{enumerate}
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot f(x_0) = (b-a)\cdot f(a) = 3\cdot1=3\]
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot (f(x_0)+f(x_1)) = \frac{b-a}{n}\cdot(f(a)+f(a+h)) =\]
		\[=\frac{3-0}{2}\cdot(f(0)+f(1.5)) = 1.5\cdot(1+(-1.227))=-0.3405\]
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot(f(x_0)+f(x_1)+f(x_2)+f(x_3)) = \]
		\[= \frac{b-a}{n}\cdot(f(a)+f(a+h)+f(a+2h)+f(a+3h))=\]
		\[=\frac{3}{4}(f(0)+f(0.75)+f(1.5)+f(2.25))=\]
		\[=0.75\cdot(1+1.04-1.227-0.0672)=0.55935\]
	\end{enumerate}
	\section{Правые прямоугольники}
	\begin{enumerate}
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot f(x_1) = (b-a)\cdot f(b) = 3\cdot9.642=28.926\]
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot (f(x_1)+f(x_2)) = \frac{b-a}{n}\cdot(f(a+h)+f(b)) =\]
		\[=\frac{3-0}{2}\cdot(f(1.5)+f(3)) = 1.5\cdot(-1.227+9.642)=12.6225\]
		\item \[\int\limits_0^3 x^2\cos(2x)+1 dx = h\cdot(f(x_0)+f(x_1)+f(x_2)+f(x_3)) = \]
		\[= \frac{b-a}{n}\cdot(f(a+h)+f(a+2h)+f(a+3h)+f(b))=\]
		\[=\frac{3}{4}(f(0.75)+f(1.5)+f(2.25)+f(3))=\]
		\[=0.75\cdot(1.04-1.227-0.0672+9.642)=7.041\]
	\end{enumerate}
	\section{Вывод и сравнение}
	Как мы видим, погрешность интегрирования очень большая, при этом значения интегралов, найденные с помощью левых и правых прямоугольников, сильно разнятся друг с другом. Отметим, что при нахождении интеграла с помощью программы точность \(0.1\) была достигнута при \(n=64\).
	\newpage
	\chapter{Контрольные тесты}
	В ходе данной работы проведем следующие исследования:
	\begin{enumerate}
		\item Изучим зависимость погрешности интегрирования от заданной точности. Будем менять точность от \(10^{-7}\) до \(10^{-6}\).
		\item Изучим зависимость количества разбиений (подотрезков) от заданной точности.
		\item Оптимизируем алгоритм так, чтобы было меньше вычислений функции \(f(x)\), т.е. значения в повторяющихся точках хранились в памяти, а не вычислялись заново. Затем изучим зависимость количества вызовов функции \(f(x)\) от заданной точности.
	\end{enumerate}
	\chapter{Модульная структура программы}
	\begin{itemize}
		\item double f(double x) --- вычисление значения функции в точке \(x\).
		\item double Formula(double a, double b, unsigned long long int n, int side) --- функция, выполняющая вычисления на текущем приближении.
		\item double FormulaOpt(double a, double b, unsigned long long int n, int side, double I) --- аналогияная функция для оптимизированного варианта метода.
		\item void Method(double a, double b, int side, FILE* file) --- функция, проверяющая условия окончания расчетов с помощью правила Рунге, а также записывающая результаты в файл.
		\item void MethodOpt(double a, double b, int side, FILE* file) --- аналогияная функция для оптимизированного варианта метода.
	\end{itemize}
	\chapter{Численный анализ}
	\section{Зависимость погрешности от точности}
	\begin{center}
		\includegraphics[scale=0.55]{error}
		\includegraphics[scale=0.55]{errormacro}
	\end{center}
	Мы можем видеть, что для левых и правых прямоугольников для данной функции на выбранном отрезке значения инттегралов довольно близки. Так получается из-за того, что даже для точности \(0.1\) требуется 64 разбиения, что на таком коротком отрезке влечет за собой малую разницу между двумя вариациями данного метода.
	\section{Зависимость количества отрезков от точности}
	\begin{center}
		\includegraphics[scale=1]{count}
	\end{center}
	Заметим, что количество отрезков разбиения совпадает для методов левых и правых прямоугольников.
	\newpage
	\section{Оптимизация метода}
	Построим графики зависимости погрешности интегрирования от точности, количества отрезков разбиения и количества вызовов функции \(f(x)\) от точности для оптимизированного метода.
	\begin{center}
		\includegraphics[scale=0.55]{errorOPT}
		\includegraphics[scale=0.55]{countOPT}
	\end{center}
	\begin{center}
		\includegraphics[scale=0.55]{leftdots}
		\includegraphics[scale=0.55]{rightdotswithnums}
	\end{center}
	Мы видим, что погрешность и количество отрезков остались теми же, как и предполагалось (поскольку мы оптимизируем только объем вычичслений, а не их качество). При этом количество вызовов функций уменьшилось вдвое. Так как по правилу Рунге мы увеличичваем количество отрезков вдвое на каждом следующем приближении, то их количество равно \(2^k\), где \(k\) --- номер шага. Количество вызовов функций прямо пропорционально количеству разбиений. Поэтому при оптимизации мы запоминаем результат прошлого приближения, а вычисляем значения функции только в новых точках, которые лежат между уже имеющимися. Их ровно столько же, поэтому вместо \(2n\) вычислений на каждом следующем приближении мы выполняем лишь \(n\). Отсюда уменьшение количества вызовов функции \(f(x)\) в два раза.
	\newpage
	\chapter{Общие выводы}
	По результатам проведенных исследований, можем отметить, что метод прямоугольников (как правых, так и левых) сходится к значению интеграла с требуемой точностью, причем линейно. Оптимизация алгоритма помогает сократить вдвое объем вычислений. При этом количество отрезков разбиения все равно растет достаточно быстро, из-за чего данный метод становится менее предпочтителен по сравнению с другими (трапеций или 3/8), хоть и является самым простым. На практике же он применяется реже всего, так как даже для низких точностей требует большого количества вычислений.
\end{document}