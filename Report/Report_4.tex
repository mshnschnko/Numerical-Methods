\documentclass[a4paper,14pt]{report}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{setspace}
\usepackage{geometry}
\geometry{top=2cm}
\geometry{bottom=2cm} % отступ снизу
\geometry{left=2cm} % отступ справа
\geometry{right=2cm} % отступ слева
\usepackage{graphicx}
\usepackage{amsmath}
\graphicspath{{./images/}}
\makeatletter %%%%% <---- Starting chapter without a pagebreak
\renewcommand\chapter{\par%
	\thispagestyle{plain}% \global\@topnum\z@
	\@afterindentfalse \secdef\@chapter\@schapter}
\makeatother

\begin{document}
	
	\begin{center}
		\hfill \break
		\begin{center}
			\huge{Санкт-Петербургский политехнический университет\\
				Высшая школа прикладной математики\\
				и вычислительной физики, ФизМех}
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		
		\huge{Направление подготовки\\
			<<Прикладная математика и информатика>>}\\
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\fontsize{14pt}{14pt}\selectfont
		Отчет по лабораторной работе №4\\
		<<Решение алгебраической проблемы собственных значений итерационными методами>>\\
		\begin{center}
			Дисциплина: <<Численные методы>>
		\end{center}
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
		\hfill \break
	\end{center}
	\hfill \break
	\hfill \break
	\fontsize{12pt}{12pt}\selectfont 
	\begin{tabular}{cccc}
		\hspace{1cm}Выполнил студент гр. 5030102/00003 & {\hspace{3cm}} & & Анищенко М.Д. \\\\
		\hspace{-3cm}Преподаватель: &{\hspace{1cm}}& & {\hspace{1cm}} Курц В.В. \\\\
	\end{tabular}\\
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\hfill \break
	\begin{center} Санкт-Петербург 2021 \end{center}
	\thispagestyle{empty}
	
	\newpage
	\tableofcontents{}
	\clearpage
	\chapter{Формулировка задачи и её формализация}
	Собственные векторы и значения --- основные характеристики матрицы. Поэтому их нахождение является важной задачей вычислительной математики. Методы нахождения можно разделить на те, которые решают частичную АПСЗ (находят max/min собственное число или максимальное близкое к заданному значению), и те, которые решают полную задачу (находят все собственные числа).
	\section{Формализация задачи}
	Пусть дана матрица \(A\) размера \(n \times n\). Соответственно она имеет \(n\) собственных чисел \(\lambda\). Требуется найти эти собственные числа с помощью итерационного метода Якоби.
	\section{Постановка задачи}
	\begin{enumerate}
		\item Исследовать условия применимости метода и алгоритм его работы.
		\item Найти все собственные числа заданным методом.
		\item Исследовать влияние отделимости СЧ на скорость сходимости итерационного процесса.
		\item Исследовать устойчивость АПСЗ.
	\end{enumerate}
	\chapter{Алгоритм метода и условия его применимости}
	Метод вращений Якоби применим к симметричным матрицам (\(A=A^\top \)).\\
	\section{Алгоритм метода}
	Итерационная формула для метода Якоби: \(A_2=T^\top _{ij}A_1T_{ij}\), где \(T\) --- матрица вращений. Напоминание о том, что такое матрица вращения:
	$$
	\hspace{3em} i \hspace{3.5em} j
	$$
	$$
	T_{ij}(\phi)=
	\begin{pmatrix}
		1& 0& \cdots& \cdots& 0\\
		0& c& \cdots& -s& \vdots\\
		\vdots& \vdots& 1& \vdots& \vdots\\
		\vdots& s& \cdots& c& \vdots\\
		0& 0& \cdots& \cdots& 1\\
	\end{pmatrix},
	$$
	где \(c = \cos(\phi)\) и \(s = \sin(\phi)\).\\
	\(T_{ij}\) поворачивает вектор \(x\) в плоскости \(Ox_ix_j\) на угол \(\phi\).\\
	\(T^{-1}_{ij} = T^\top _{ij}\).\\
	При этом действие \(A_2=T^\top _{ij}A_1T_{ij}\) можно выполнить по следуюему алгоритму:
	$$
	B=AT_{ij}
	$$
	$$
	b_{kl}=
	\begin{cases}
		a_kl& \forall k,l\neq i,j\\
		a_{ki}c + a_{kj}s& \forall k,l=i\\
		-a_{ki}s+a_{kj}c& \forall k,l=j\\
	\end{cases}
	$$
	$$
	\tilde{A}=T^\top_{ij}B
	$$
	$$
	\tilde{a}_{kl}=
	\begin{cases}
		b_kl& \forall l,k \neq i.j\\
		b_{il}c+b_{jl}s& \forall l,k=i\\
		-b_{il}s+b_{jl}c& \forall l,k=j\\
	\end{cases}
	$$
	Введём следующие обозначения:\\
	Норма Фробениуса: \(||A||_F=\sqrt{\sum\limits_{i,j}a^2_{ij}}\).\\
	 \(||A||^2_F=\sum\limits_{i=1}^{n} a^2_{ii} + \sum\limits_{i\neq j}^{} a^2_{ij} = S_1(A) + S_2(A)\).\\
	 Угол поворота \(\phi\) для матрицы \(T\) должен удовлетворять условию: \(\tan(2\phi)=\frac{2a^{(1)}_{ij}}{a^{(1)}_{ii}-a^{(1)}_{jj}}\).\\
	 Условие остановки: \(S_2(A_k)<\varepsilon\)
	 \subsection{Алгоритм с выбором оптимального элемента}
	 \(A_2=T^\top _{ij}A_1T_{ij}\)\\
	 \(r_k=\sum\limits_{j=1,j\neq k}^n (a^{(1)}_{kj})^2 \Rightarrow S_2(A_1)=\sum\limits_k r_k\).\\
	 \(i_0:r_{i_0} = \max\limits_k r_k\)\\
	 \(j_0:|a^{(1)}_{i_0j_0}|=\max\limits_{i,j\neq i_0} |a^{(1)}_{i_0j}|\).
	 \newpage
	 \chapter{Анализ задачи}
	 АПСЗ наиболее устойчива, если \(A=A^\top \). Зададим матрицу как \(A=QDQ^\top \), где \(Q\) --- ортогональная матрица, \(D\) --- диагональная. Также такой способ поможет контролировать отделимость собственных чисел.
	 \chapter{Тестовый пример}
	 Возьмём для примера матрицу 3$\times$3:
	 $$
	 D=
	 \begin{pmatrix}
	 	1& 0& 0\\
	 	0& 2& 0\\
	 	0& 0& 3\\
	 \end{pmatrix}
 	 Q=
 	 \begin{pmatrix}
 	 	-0.7092& -0.1260& -0.6936\\
 	 	-0.3030& -0.8339& 0.4612\\
 	 	-0.6365& 0.5373& 0.5533\\
 	 \end{pmatrix}
	 A_1=
	 \begin{pmatrix}
	 	1.9781& -0.5348& -0.8352\\
	 	-0.5348& 2.1209& 0.0623\\
	 	-0.8352& 0.0623& 1.9009\\
	 \end{pmatrix}
	 $$
	 Будем действовать согласно алгоритму, устанавливая погрешность \(\varepsilon=0.01\). Нумерация начинается с нуля.
	 \begin{enumerate}
		 \item
		 $$
		 i_0 = 0, j_0=2
		 $$
		 $$
		 \tan(2\phi) = -21.636455; \phi = -0.762305.
		 $$
		 $$
		 A_2=
		 \begin{pmatrix}
		 	2.775661& -0.429850& 0\\
		 	-0.429850& 2.120933& -0.324269\\
		 	0& -0.324269& 1.103405\\
		 \end{pmatrix}
		 $$
		 \item
		 $$
		 i_0 = 1, j_0=0
		 $$
		 $$
		 \tan(2\phi)=1.313064; \phi=0.459963.
		 $$
		 $$
		 A_3=
		 \begin{pmatrix}
		 	2.988610& 0& 0.143948\\
		 	0& 1.907984& -0.290567\\
		 	0.143948& -0.290567& 1.103405\\
		 \end{pmatrix}
		 $$
		 \item
		 $$
		 i_0 = 2, j_0=1
		 $$
		 $$
		 \tan(2\phi)=0.722284; \phi=0.312763.
		 $$
		 $$
		 A_4=
		 \begin{pmatrix}
		 	2.988610& -0.044291& 0.136965\\
		 	-0.044291& 2.001947& 0\\
		 	0.136965& 0& 1.009443\\
		 \end{pmatrix}
		 $$
		 \item
		 $$
		 i_0 = 0, j_0=2
		 $$
		 $$
		 \tan(2\phi)=0.138406; \phi=0.068766.
		 $$
		 $$
		 A_5=
		 \begin{pmatrix}
		 	2.998044& -0.044186& 0\\
		 	-0.044186& 2.001947& 0.003043\\
		 	0& 0.003043& 1.000009\\
		 \end{pmatrix}
		 $$
 	 \end{enumerate}
	 Отсюда \(\lambda_1=2.998044, \lambda_2=2.001947, \lambda_3=1.000009\). Заданные нами собственные числа равны \(\lambda^*_1=3, \lambda^*_2=2, \lambda^*_3=1\). Как мы можем наблюдать, собственные значения, полученные с помощью метода Якоби, заметно приблизились к точным за 4 итерации.
	 \chapter{Контрольные тесты}
	 Создадим две матрицы с хорошей и плохой отделимостями, равными 0.1 и 0.99 соответственно, и посмотрим, как отделимость влияет на количество итераций, необходимое для нахождения собственных чисел с заданной точностью. Точность мы будем менять от \(10^{-15} \text{ до } 10^{-3}\).
	 \chapter{Модульная структура программы}
	 \begin{itemize}
	 	\item double** CreateMatrix(int n, int m) --- функция выделения памяти под матрицу размера \(n \times m\).
	 	\item void DestroyMatrix(double** A, int n) --- функция удаления матрицы и очистки памяти.
	 	\item double** ReadMatrix(FILE* matrixfile, int n) --- функция считывания матрицы из файла.
	 	\item void ChoosingTheOptimalElement(double** matrix, int n, int* i0, int* j0) --- функция выбора оптимального элемента \(a_{i_0j_0}\).
	 	\item double getPhi(double** matrix, int i, int j) --- функция нахождения угла поворота $\phi$.
	 	\item double** TAT(double** matrix, int n, double phi, int i, int j) --- функция матричного умножения \(T^\top AT\).
	 	\item double StopCondition(double** matrix, int n) --- функция проверки выполнения уловия остановки.
	 	\item void GetSeparability(double** matrix, FILE* separabilityFile, int n, int iters) --- функция записи в файл количества итераций, соответствующего конкретному показателю отделимости.
	 	\item void GetEigenValues(double** matrix, int n, FILE* EigenValues) --- функция записи в файл собственных значений, найденных с помощью выбранного метода.
	 	\item double** Jacobi(double** matrix, int n, int* iters) --- функция, осущестляющая выполнение поиска собственных значений матрицы с помощью метода Якоби.
	 \end{itemize}
	\chapter{Численне результаты}
	%\section{Влияние отделимости на количество итераций}
	Зададим 2 разных показателя отделимости (хорошая отделимость = 0.1 и плохая = 0.99) и будем считать количество итераций при разной точности.
	\begin{center}
		\includegraphics{sep2}
	\end{center}
	Из графика мы видим, что количество итераций для хорошей отделимости больше, чем для плохой, то есть, чем ближе собственные значения матрицы друг к другу, тем меньше вычислений нам потребуется.
	\newpage
	%\section{Устойчивость АПСЗ}
	%Для исследования метода на устойчивость будем вносить возмущения разных порядков (от \(10^{-5}\) до \(1\)) и вычислять относительную погрешность найденных собственных значений и собственных векторов. В качестве точных собственных значений будем использовать числа и векторы, полученные с помощью операции eig() в MATLAB.
	%\begin{center}
		%\includegraphics[scale=0.55]{stability1}
		%\includegraphics[scale=0.55]{stability2}
	%\end{center}
	%Из графика видно, что данная зависимость в логарифмических осях имеет линейную зависимость. Как и ожидалось, при увеличении возмущения увеличивается и относительная погрешность вычислений.
	\chapter{Общие выводы}
	В данной работе был реализован метод Якоби. Анализируя наши исследования, заметим, что данный метод для симметричных матриц достаточно быстро находит собственные значения матрицы. Также мы выяснили, что при хорошей отделимости метод сходится медленнее, чем при плохой, когда собственные числа матрицы находятся близко друг к другу.
\end{document}